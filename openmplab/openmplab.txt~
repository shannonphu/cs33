At first I tried to examine all files to understand what the code was doing exactly to aid in my
optimizations, but eventually I realized that the main purpose of the lab was to utilize OpenMP
to parallelize code to make it run faster. I looked up resources to learn how to use the OpenMP
directives so I knew that I had to use things such as #pragma omp parallel and/or #pragma omp
parallel for. I attempted to just put those above every for loop essentially, but this either
would make the program take a very long time to complete or would even change the output. When
I ran make check on those attempts, I very frequently got the message that my output was not
correct and differed from the expected output. I knew using parallel in my directives caused
this problem so I ended up changing all my #pragma omp parallel directives to  simply #pragma
omp for, but this method did not yield any speed up at all and rather ocassionally slowed
down my code. I took a look at the code profile by doing make seq GPROF=1 to examine which function
of the 5 was taking the most time and found that func01 was taking up the most time. So I tried
to spend more of my efforts in parallelizing that function. So in the largest for loop which
had 2 for loops nested within, I tried to parallelize that larger for loop with #pragma omp
parallel for. This did not work out well as it changed the output of my program. I read on
Piazza that the concept of shared and private could be useful in the case of race conditions
so I applied that to variables related to those loops. This actually worked and caused about
a 6x speed-up of func.c. I was working on lnxsrv05. To make sure my results were valid, I ran make
check again to ensure that my output was correct to the original program and I also ran
make checkmem to check for memory leaks. I got a list of memory leaks, but as from a certain
Piazza post, many others were also getting these memory leaks as well. To get an average reading
of func.c's speed up, I ran the timing script provided by a TA. I did python esttime.py ./seq 10
resulting in a mean of
and python esttime.py ./omp 10
