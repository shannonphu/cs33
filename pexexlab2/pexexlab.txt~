I at first tried to put in emacs -batch -eval '(print (* 37 -26))' but that did not work. I am not familar with the GDB debugger, so I played around with GDB and looked up some of its instructions. To start the traces, I tried:
gdb --args ~eggert/bin32/bin/emacs-24.5 -batch -eval '(print (* 37 -26))'
dir ~eggert/bin32/bin/emacs-24.5 
But dir ~eggert/bin32/bin/emacs-24.5 was not "found" so I tried dir ~eggert/src/emacs-24.5/ and eventually just dir ~eggert/src. I gave the command set disassemble-next-line on, set a breakpoint at Ftimes, and ran the program. I was confused between the difference between step/stepi and next/nexti, so I spent some time alternating between the two. My first problem was when I used stepi, after the function jumped into arith_driver, it also jumped into other functions it called and never seemed to reach the ret instruction. Since the total number of machine instructions was only supposed to be about ~100 lines, I was getting way more than that. I eventually ended up using next or nexti to get the result I was expecting. To get the trace, I just steped through each line of the assembly code and printed info reg each step. As for trace2, I followed the same procedure that worked for me except switching the bin to bin64. After copying and pasting all relevent data to emacs, I manually formatted everything.

For the second part of the lab, examining integer overflow, I wasn't quite sure how to compile the code to assembly language. I considered things like objdump, but what turned out to work was gcc -o2 -s filename.c. I saved the resulting assembly code in three seperate text files to compare.