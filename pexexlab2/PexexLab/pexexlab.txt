I at first tried to put in emacs -batch -eval '(print (* 37 -26))' but that did not work. I am not familar with the GDB debugger, so I played around with GDB and looked up some of its instructions. To start the traces, I tried:
gdb --args ~eggert/bin32/bin/emacs-24.5 -batch -eval '(print (* 37 -26))'
dir ~eggert/bin32/bin/emacs-24.5 
But dir ~eggert/bin32/bin/emacs-24.5 was not "found" so I tried dir ~eggert/src/emacs-24.5/ and eventually just dir ~eggert/src. I gave the command set disassemble-next-line on, set a breakpoint at Ftimes, and ran the program. I was confused between the difference between step/stepi and next/nexti, so I spent some time alternating between the two. My first problem was when I used stepi, after the function jumped into arith_driver, it also jumped into other functions it called and never seemed to reach the ret instruction. Since the total number of machine instructions was only supposed to be about ~100 lines, I was getting way more than that. I eventually ended up using next or nexti to get the result I was expecting. To get the trace, I just steped through each line of the assembly code and printed info reg each step. As for trace2, I followed the same procedure that worked for me except switching the bin to bin64. After copying and pasting all relevent data to emacs, I manually formatted everything.

For the second part of the lab, examining integer overflow, I wasn't quite sure how to compile the code to assembly language. I considered things like objdump, but what turned out to work was gcc -o2 -s filename.c. I saved the resulting assembly code in three seperate text files to compare. I saw the assembly code had some differences but no fundamental difference was obvious to me except for trace1 which was relatively short and just xor'ed %eax and %eax. I eventually added an int main to all the function and that led me to see that for -O2 -ftrapv, another function was called.

As for the questions at the end, they were all pretty difficult. I had to compare line numbers for each of the traces. I also tried to compile the computation 37 * -26 with the -O2 optimization and -ftrapv and -fwrapv and examined the assembly code and ther eturn values. I had some trouble with making an executable, running it, and seeing the return value. I was confused about how to find problems with -ftrapv and -fwrapv. I noticed that -ftrapv did not work mostly with the -O2 optimization.
